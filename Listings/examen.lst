C51 COMPILER V9.60.0.0   EXAMEN                                                            05/14/2023 18:16:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE EXAMEN
OBJECT MODULE PLACED IN .\Objects\examen.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE examen.c OPTIMIZE(8,SPEED) BROWSE NOAREGS DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\examen.lst) TABS(2) OBJECT(.\Objects\examen.obj)

line level    source

   1          #include <reg552.h>
   2          
   3          #define BASE_DE_TIEMPO 50000
   4          #define FREQ_OSC       11.0592
   5          #define DESB_x_SEG     20
   6          
   7          // Declaracion de funciones
   8          void inicializar(void);
   9          unsigned int conversionAD(unsigned char);
  10          
  11          // Entradas
  12          sbit marcha = 0x80;
  13          
  14          // Salidas
  15          sbit tapaComida        = 0x90;
  16          sbit circutoCalentador = 0x91;
  17          sbit luz               = 0x97;
  18          
  19          // Bombas
  20          // Entradas
  21          sbit bombasON = 0x87;
  22          // salidas
  23          sbit B1 = 0xB0;
  24          sbit B2 = 0xB1;
  25          sbit B3 = 0xB2;
  26          
  27          // Variables globales
  28          unsigned char TL_0, TH_0;
  29          unsigned int contador30seg;
  30          unsigned int contador5seg;
  31          unsigned int contador12seg;
  32          
  33          void main(void)
  34          {
  35   1      
  36   1          // Inicializamos las configuraciones iniciales
  37   1          inicializar();
  38   1      
  39   1          // BUCLE PRINCIPAL INFINITO
  40   1      
  41   1          while (1) {
  42   2              while (marcha == 0) {
  43   3                  // Salidas a 0 preparadas para empezar el ciclo
  44   3                  tapaComida        = 0;
  45   3                  luz               = 0;
  46   3                  circutoCalentador = 0;
  47   3                  B1 = 0;
  48   3                  B2 = 0;
  49   3                  B3 = 0;
  50   3                  // Carga en el TR0 para poder comenzar a contar cuando marcha on
  51   3                  TL0 = TL_0;
  52   3                  TH0 = TH_0;
  53   3                  // Para poder partir de cero cuando pasamos de paro a marcha es necesario inicializar lo conta
             -dores
C51 COMPILER V9.60.0.0   EXAMEN                                                            05/14/2023 18:16:12 PAGE 2   

  54   3                  // si no seria una pausa, y queremos que comience el ciclo desde el inicio
  55   3                  contador30seg = 0;
  56   3                  contador5seg  = 0;
  57   3                  contador12seg = 0;
  58   3                  
  59   3              }
  60   2              // La luz siempre que esta en marcha esta ON
  61   2              luz = 1;
  62   2          }
  63   1      }
  64          
  65          // DEFINICION DE FUNCIONES//
  66          
  67          // INICIALIZAR
  68          
  69          void inicializar(void)
  70          {
  71   1      
  72   1          // Variables locales
  73   1          unsigned int valorInicialTimer0;
  74   1      
  75   1          // Configuramos el timer TR0 16 bits modo 1 (01) 000 0001
  76   1          TMOD = TMOD | 0x01;
  77   1      
  78   1          // Calculo del valor inicial TR0
  79   1          valorInicialTimer0 = (0xFFFF - 1) - BASE_DE_TIEMPO * FREQ_OSC / 12.0;
  80   1          // Cargamos valores
  81   1          TL_0 = valorInicialTimer0;
  82   1          TH_0 = valorInicialTimer0 >> 8;
  83   1          TL0  = TL_0;
  84   1          TH0  = TH_0;
  85   1      
  86   1          // Interrupciones
  87   1          EA  = 1; // habilita interrupciones globales
  88   1          ET0 = 1; // habilita la interrupcion timer0
  89   1      
  90   1          // SAlidas
  91   1          tapaComida        = 0;
  92   1          luz               = 0;
  93   1          circutoCalentador = 0;
  94   1          B1 = 0;
  95   1          B2 = 0;
  96   1          B3 = 0;
  97   1      
  98   1          // Ponemos en marcha el TR0
  99   1          TR0 = 1;
 100   1      }
 101          
 102          // INTERRUPCION
 103          void interrupcionTR0(void) interrupt 1 using 1
 104          {
 105   1      
 106   1          // Varibles
 107   1      
 108   1          float temperatura;
 109   1      
 110   1          // Cargamos valores en el TR0
 111   1          TL0 = TL_0;
 112   1          TH0 = TH_0;
 113   1      
 114   1          // Sumamos un desbordamiento
 115   1          contador30seg++;
C51 COMPILER V9.60.0.0   EXAMEN                                                            05/14/2023 18:16:12 PAGE 3   

 116   1          contador5seg++;
 117   1          //Si tenemos el modo oleaje
 118   1          if (bombasON == 1){
 119   2          contador12seg++;
 120   2          }
 121   1      
 122   1          // Comprobamos que estamos en los 3 primeros segundos del ciclo
 123   1          if ((contador30seg >= (0 * DESB_x_SEG)) && (contador30seg <= (3 * DESB_x_SEG))) {
 124   2              tapaComida = 1;
 125   2          }
 126   1      
 127   1          if ((contador30seg >= (3 * DESB_x_SEG)) && (contador30seg <= (30 * DESB_x_SEG))) {
 128   2              tapaComida = 0;
 129   2          }
 130   1          // Termina el ciclo de 30 segundos y reseteamos el contador
 131   1          if (contador30seg == (30 * DESB_x_SEG))
 132   1       { contador30seg = 0; }
 133   1      
 134   1          // Control de temperatura
 135   1      
 136   1          if (contador5seg == (5 * DESB_x_SEG)) {
 137   2              // Reset contador 5seg
 138   2              contador5seg = 0;
 139   2              // Obtenemos la temperatura
 140   2              temperatura = (47.5 / 1023) * conversionAD(0) + 2.5;
 141   2              // Si temperatura es 24 o mayor circuito off
 142   2              if (temperatura >= 27.4) {
 143   3                  // Circuito off
 144   3                  circutoCalentador = 0;
 145   3              } else {
 146   3                  circutoCalentador = 1;
 147   3              }
 148   2          }
 149   1      
 150   1          // Modo oleaje
 151   1          
 152   1          //Mientras bombasON = 0
 153   1              if(bombasON == 0){
 154   2                contador12seg = 0;
 155   2                B1 = 0;
 156   2                B2 = 0;
 157   2                B3 = 0;
 158   2              } 
 159   1      
 160   1          if (bombasON == 1) {
 161   2              // Ciclo 1 B1 ON 6seg
 162   2              if ((contador12seg >= (0 * DESB_x_SEG)) && (contador12seg < (6 * DESB_x_SEG))) {
 163   3                  // bomba 1 on
 164   3                  B1 = 1;
 165   3                  B2 = 0;
 166   3                  B3 =0;
 167   3              }
 168   2              // Ciclo 2 B1 OFF B2 Y B3 ON
 169   2              if ((contador12seg >= (6 * DESB_x_SEG)) && (contador12seg < (8 * DESB_x_SEG))) {
 170   3                  // bomba 1 off y bomba 2 y 3 on
 171   3                  B1 = 0;
 172   3                  B2 = 1;
 173   3                  B3 = 1;
 174   3              }
 175   2              // Ciclo 3 todas on
 176   2              if ((contador12seg >= (8 * DESB_x_SEG)) && (contador12seg < (12 * DESB_x_SEG))) {
 177   3                  // bomba 1 off y bomba 2 y 3 on
C51 COMPILER V9.60.0.0   EXAMEN                                                            05/14/2023 18:16:12 PAGE 4   

 178   3                  B1 = 1;
 179   3                  B2 = 1;
 180   3                  B3 = 1;
 181   3              }
 182   2              if (contador12seg == (12 * DESB_x_SEG)) {
 183   3                  // reset contador 12seg
 184   3                  contador12seg = 0;
 185   3              }
 186   2          }
 187   1      }
 188          
 189          // CONVERSION ANALOGICA DIGITAL
 190          
 191          unsigned int conversionAD(unsigned char canal)
 192          {
 193   1      
 194   1          // Inicializamos ADCON
 195   1          ADCON = ADCON & 0x00;
 196   1          // Configuramos el canal de lectura en este caso el 0 pin P5.0
 197   1          ADCON = ADCON | canal;
 198   1      
 199   1          // Iniciamos la conversion
 200   1          ADCON = ADCON = 0x08;
 201   1      
 202   1          // Esperamos a terminar la conversion
 203   1          while ((ADCON & 0x10) == 0)
 204   1              ;
 205   1      
 206   1          // Cuando termina la conversion ponemos ADCI a 0 ADCS se pone a cero solo
 207   1          ADCON = ADCON & 0xEF;
 208   1      
 209   1          // Devolvemos el valor
 210   1          return (ADCON >> 6 | ADCH << 2);
 211   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    428    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
