C51 COMPILER V9.60.0.0   EXAMEN                                                            05/15/2023 10:31:39 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE EXAMEN
OBJECT MODULE PLACED IN .\Objects\examen.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE examen.c OPTIMIZE(8,SPEED) BROWSE NOAREGS DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\examen.lst) TABS(2) OBJECT(.\Objects\examen.obj)

line level    source

   1          #include <reg552.h>
   2          
   3          #define BASE_TIEMPO 50000
   4          #define FREQ_OSCI   12.0
   5          #define DESB_x_SEG  20
   6          
   7          // Declaracion de funciones
   8          void inicializar(void);
   9          
  10          // Variables globales
  11          sbit marcha    = 0xC0;
  12          sbit sentido   = 0xC1;
  13          sbit velocidad = 0xC2;
  14          
  15          unsigned char TL_0, TH_0;
  16          unsigned char indice;
  17          
  18          void main(void)
  19          {
  20   1      
  21   1          inicializar();
  22   1          while (1) {
  23   2      
  24   2              /*PROBLEMA CON ESTE WHILE SI LO DEJAS SIN CODIGO DENTRO SALTA LA INTERRUPCION SIEMPRE,
  25   2              AL NO TENER CODIGO SUPONGO QUE ENTRE QUE SALE DEL WHILE Y VUELVE A COMPROBAR ENTRA LA INTERRUCION
  26   2              Y EJECUATA EL CODIGO
  27   2              LA EXPLICACION ES QUE SI TIENE CODIGO EJECUTA EL CODIGO Y DESDE DENTRO DEL WHILE COMPRUEBA LA COND
             -ICION
  28   2              SI EL WHILE ESTA VACIO SALE Y VUELVE A VALORAR LA EXPRESION, EN ESO MOMENTO SALTA LA INTERRUPCION*
             -/
  29   2            while (marcha == 0); { P1 = 0xFF; }
  30   2          }
  31   1      }
  32          
  33          // Definicion de funciones
  34          
  35          void inicializar(void)
  36          {
  37   1          // Variables locales
  38   1          unsigned int valor_inicial_TR0;
  39   1      
  40   1          // Configuramos TMOD para el TR0 modo 16bits
  41   1          TMOD = 0x01;
  42   1          // Calculamos la carga inicial de temporizador
  43   1          valor_inicial_TR0 = (0xFFFF - 1) - BASE_TIEMPO * FREQ_OSCI / 12.0;
  44   1          // Carga de los valores en TR0
  45   1          TL_0 = valor_inicial_TR0;
  46   1          TH_0 = valor_inicial_TR0 >> 8;
  47   1          TL0  = TL_0;
  48   1          TH0  = TH_0;
  49   1      
  50   1          // Configuracion interrupciones
  51   1          EA  = 1; // Interrupciones globales activadas
  52   1          ET0 = 1; // Interrupcion TR0 activada
C51 COMPILER V9.60.0.0   EXAMEN                                                            05/15/2023 10:31:39 PAGE 2   

  53   1      
  54   1          // Encendemos la primera secuencia segun sea el valor de sentido y fijamos en que posicion del indice 
             -estariamos
  55   1          if (sentido == 1) {
  56   2              P1     = 0x80;
  57   2              indice = 1;
  58   2          }
  59   1          if (sentido == 0) {
  60   2              P1     = 0xFF;
  61   2              indice = 16;
  62   2          }
  63   1      
  64   1          // Ponemos en marcha el TR0
  65   1          TR0 = 1;
  66   1      }
  67          
  68          void interrupcionTR0(void) interrupt 1 using 1
  69          {
  70   1          /*Posible solucion al problema del while, si metemos todo el codigo que se ejecuta en la
  71   1          interrupcion en un if,mejor opcion meter codigo en el while*/
  72   1      
  73   1          // Variables locales **ESTE ARRAY HA DADO PROBLEMAS PONIENDO LA EXPRESION EN BINARIO**
  74   1          unsigned char code codigo[18] = {0x80,
  75   1                                           0x40,
  76   1                                           0x20,
  77   1                                           0x10,
  78   1                                           0x08,
  79   1                                           0x04,
  80   1                                           0x02,
  81   1                                           0x01,
  82   1                                           0xAA,
  83   1                                           0x55,
  84   1                                           0x80,
  85   1                                           0xC0,
  86   1                                           0xE0,
  87   1                                           0xF0,
  88   1                                           0xF8,
  89   1                                           0xFC,
  90   1                                           0xFE,
  91   1                                           0xFF};
  92   1          static unsigned char contador;
  93   1      
  94   1          unsigned char desbordamientos;
  95   1      
  96   1          /* Recarga Carga TR0 SUPER IMPORTANTE, NO DEJA DE FUNCIONAR PERO DA ERRORES DE TIMEPO, VA A SUMAR
  97   1             EL CONTADOR ENTERO, PARA DETECTAR ESTE FALLO EN UN SEGUNDO CONTARIA +- EL DOBLE DEL MAXIMO UNOS 130
             -000
  98   1             MICRO SEGUNDOS*/
  99   1          TL0 = TL_0;
 100   1          TH0 = TH_0;
 101   1      
 102   1          // Comprobamos velocidad y la fijamos los desbordamientos
 103   1          // VELOCIDAD 1/2 SEGUNDO
 104   1          if (velocidad == 0) {
 105   2              desbordamientos = DESB_x_SEG / 2;
 106   2              if (contador > 10) { contador = 0; } /*SI NO SE PONE A CERO Y EL CONTADOR ESTA POR NECIMA DEL VALO
             -R
 107   2                                                     DE DESBORDAMIENTO SIGUE SUBIENDO HASTA DESBORDAR LA VARIABL
             -E*/
 108   2          }
 109   1          // VELOCIDAD 1 SEGUNDO
 110   1          if (velocidad == 1) {
C51 COMPILER V9.60.0.0   EXAMEN                                                            05/15/2023 10:31:39 PAGE 3   

 111   2              desbordamientos = DESB_x_SEG;
 112   2          }
 113   1      
 114   1          contador++;
 115   1      
 116   1          // Verificamos el valor de contador para cambiar el codigo y el sentido de la secuencia
 117   1          // Sentido bajada
 118   1          if ((contador == desbordamientos) && (sentido == 1)) {
 119   2      
 120   2              // Aplicamos la senal de control
 121   2              P1 = codigo[indice];
 122   2              // Desplazamos el indice de array
 123   2              indice++;
 124   2              // Reseteamos contador
 125   2              contador = 0;
 126   2              // Si tenemos el indice desbordado lo reseteamos al primer valor de indice segun su direccion
 127   2              if (indice == 18) { indice = 0; }
 128   2          }
 129   1      
 130   1          // Sentido subida
 131   1          if ((contador == desbordamientos) && (sentido == 0)) {
 132   2      
 133   2              // Aplicamos la senal de control
 134   2              P1 = codigo[indice];
 135   2              // Desplazamos el indice de array
 136   2              indice--;
 137   2              // Reseteamos contador
 138   2              contador = 0;
 139   2              // Si tenemos el indice desbordado lo reseteamos al primer valor de indice segun su direccion
 140   2              if (indice == 0) { indice = 17; }
 141   2          }
 142   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    162    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
